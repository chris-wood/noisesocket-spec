<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Alexey Ermishkin (scratch@virgilsecurity.com)" />
  <meta name="date" content="2017-05-01" />
  <title>The NoiseSocket Protocol</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="spec_markdown.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">The NoiseSocket Protocol</h1>
<b>Author:</b> Alexey Ermishkin (scratch@virgilsecurity.com)<br/>
<b>Revision:</b> 0draft<br/>
<b>Date:</b> 2017-05-01<br/>
</div>
<div id="TOC">
<h2 class="toc">Table of Contents</h2>
<ul>
<li><a href="#abstract"><strong>Abstract</strong></a></li>
<li><a href="#crypto">1. Crypto</a><ul>
<li><a href="#dh-functions">1.1. DH functions</a></li>
<li><a href="#cipher-functions">1.2. Cipher functions</a></li>
<li><a href="#hash-functions">1.3. Hash functions</a></li>
</ul></li>
<li><a href="#messages">2. Messages</a><ul>
<li><a href="#first-handshake-message">2.1. First handshake message</a></li>
<li><a href="#second-handshake-message">2.2. Second handshake message</a></li>
<li><a href="#third-handshake-message">2.3. Third handshake message</a></li>
<li><a href="#data-message">2.4. Data message</a></li>
</ul></li>
<li><a href="#prologue">3. Prologue</a></li>
<li><a href="#api">5. API</a></li>
<li><a href="#test-vectors">6. Test vectors</a></li>
<li><a href="#ipr">7. IPR</a></li>
<li><a href="#references">8. References</a></li>
</ul>
</div>
<h1 id="abstract"><strong>Abstract</strong></h1>
<p>NoiseSocket is an extension of the Noise Protocol Framework (developed by the authors of Signal and currently used by WhatsApp) that enables quick and seamless Transport Layer Security (TLS) between multiple parties with minimal code space overhead, small keys, and extremely fast speed. NoiseSocket is designed to overcome the shortcomings of existing TLS implementations and targets IoT devices, microservices, back-end applications such as datacenter-to-datacenter communications, and use cases where third-party certificate of authority infrastructure is not optimal.</p>
<h1 id="crypto">1. Crypto</h1>
<p>Each party maintains the following variables:</p>
<ul>
<li><p><strong><code>s, e</code></strong>: The local party's static and ephemeral key pairs (which may be empty).</p></li>
<li><p><strong><code>rs, re</code></strong>: The remote party's static and ephemeral public keys (which may be empty).</p></li>
<li><p><strong><code>h</code></strong>: A <strong>handshake hash</strong> value that hashes all the handshake data that's been sent and received.</p></li>
<li><p><strong><code>ck</code></strong>: A <strong>chaining key</strong> that hashes all previous DH outputs. Once the handshake completes, the chaining key will be used to derive the encryption keys for transport messages.</p></li>
<li><p><strong><code>k, n</code></strong>: An encryption key <code>k</code> (which may be empty) and a counter-based nonce <code>n</code>. Whenever a new DH output causes a new <code>ck</code> to be calculated, a new <code>k</code> is also calculated. The key <code>k</code> and nonce <code>n</code> are used to encrypt static public keys and handshake payloads. Encryption with <code>k</code> uses some <strong>AEAD</strong> cipher mode (in the sense of Rogaway <span class="citation">[<a href="#ref-Rogaway:2002">1</a>]</span>) and uses the current <code>h</code> value as <strong>associated data</strong> which is covered by the AEAD authentication. Encryption of static public keys and payloads provides some confidentiality and key confirmation during the handshake phase.</p></li>
</ul>
<p>NoiseSocket protocol is instantiated with a concrete set of <strong>DH functions</strong>, <strong>cipher functions</strong>, and a <strong>hash function</strong>. The signature for these functions is defined below.</p>
<h2 id="dh-functions">1.1. DH functions</h2>
<p>Noise depends on the following <strong>DH functions</strong> (and an associated constant):</p>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Generates a new Diffie-Hellman key pair. A DH key pair consists of <code>public_key</code> and <code>private_key</code> elements. A <code>public_key</code> represents an encoding of a DH public key into a byte sequence of length <code>DHLEN</code>. The <code>public_key</code> encoding details are specific to each set of DH functions.</p></li>
<li><p><strong><code>DH(key_pair, public_key)</code></strong>: Performs a Diffie-Hellman calculation between the private key in <code>key_pair</code> and the <code>public_key</code> and returns an output sequence of bytes of length <code>DHLEN</code>.</p>
<p>The <code>public_key</code> either encodes some value in a large prime-order group (which may have multiple equivalent encodings), or is an invalid value. Implementations must handle invalid public keys either by returning some output which is purely a function of the public key and does not depend on the private key, or by signaling an error to the caller. The DH function may define more specific rules for handling invalid values.</p></li>
<li><p><strong><code>DHLEN</code></strong> = A constant specifying the size in bytes of public keys and DH outputs. For security reasons, <code>DHLEN</code> must be 32 or greater.</p></li>
</ul>
<h2 id="cipher-functions">1.2. Cipher functions</h2>
<p>Noise depends on the following <strong>cipher functions</strong>:</p>
<ul>
<li><p><strong><code>ENCRYPT(k, n, ad, plaintext)</code></strong>: Encrypts <code>plaintext</code> using the cipher key <code>k</code> of 32 bytes and an 8-byte unsigned integer nonce <code>n</code> which must be unique for the key <code>k</code>. Returns the ciphertext. Encryption must be done with an &quot;AEAD&quot; encryption mode with the associated data <code>ad</code> (using the terminology from <span class="citation">[<a href="#ref-Rogaway:2002">1</a>]</span>) and returns a ciphertext that is the same size as the plaintext plus 16 bytes for authentication data. The entire ciphertext must be indistinguishable from random if the key is secret.</p></li>
<li><p><strong><code>DECRYPT(k, n, ad, ciphertext)</code></strong>: Decrypts <code>ciphertext</code> using a cipher key <code>k</code> of 32 bytes, an 8-byte unsigned integer nonce <code>n</code>, and associated data <code>ad</code>. Returns the plaintext, unless authentication fails, in which case an error is signaled to the caller.</p></li>
</ul>
<h2 id="hash-functions">1.3. Hash functions</h2>
<p>Noise depends on the following <strong>hash function</strong> (and associated constants):</p>
<ul>
<li><p><strong><code>HASH(data)</code></strong>: Hashes some arbitrary-length data with a collision-resistant cryptographic hash function and returns an output of <code>HASHLEN</code> bytes.</p></li>
<li><p><strong><code>HASHLEN</code></strong> = A constant specifying the size in bytes of the hash output. Must be 32 or 64.</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = A constant specifying the size in bytes that the hash function uses internally to divide its input for iterative processing. This is needed to use the hash function with HMAC (<code>BLOCKLEN</code> is <code>B</code> in <span class="citation">[<a href="#ref-rfc2104">2</a>]</span>).</p></li>
</ul>
<p>Noise defines additional functions based on the above <code>HASH()</code> function:</p>
<ul>
<li><p><strong><code>HMAC-HASH(key, data)</code></strong>: Applies <code>HMAC</code> from <span class="citation">[<a href="#ref-rfc2104">2</a>]</span> using the <code>HASH()</code> function. This function is only called as part of <code>HKDF()</code>, below.</p></li>
<li><strong><code>HKDF(chaining_key, input_key_material, num_outputs)</code></strong>: Takes a <code>chaining_key</code> byte sequence of length <code>HASHLEN</code>, and an <code>input_key_material</code> byte sequence with length either zero bytes, 32 bytes, or <code>DHLEN</code> bytes. Returns a pair or triple of byte sequences each of length <code>HASHLEN</code>, depending on whether <code>num_outputs</code> is two or three:
<ul>
<li>Sets <code>temp_key = HMAC-HASH(chaining_key, input_key_material)</code>.</li>
<li>Sets <code>output1 = HMAC-HASH(temp_key, byte(0x01))</code>.</li>
<li>Sets <code>output2 = HMAC-HASH(temp_key, output1 || byte(0x02))</code>.</li>
<li>If <code>num_outputs == 2</code> then returns the pair <code>(output1, output2)</code>.</li>
<li>Sets <code>output3 = HMAC-HASH(temp_key, output2 || byte(0x03))</code>.</li>
<li>Returns the triple <code>(output1, output2, output3)</code>.</li>
</ul></li>
</ul>
<p>Note that <code>temp_key</code>, <code>output1</code>, <code>output2</code>, and <code>output3</code> are all <code>HASHLEN</code> bytes in length. Also note that the <code>HKDF()</code> function is simply <code>HKDF</code> from <span class="citation">[<a href="#ref-rfc5869">3</a>]</span> with the <code>chaining_key</code> as HKDF <code>salt</code>, and zero-length HKDF <code>info</code>.</p>
<h1 id="messages">2. Messages</h1>
<p>There are four types of messages, each prefixed by a 2-byte length. * Section <a href="first-handshake-message">2.1</a> The handshake initiation message that starts the handshake process for establishing a secure session * Section <a href="second-handshake-message">2.2</a> The handshake response to the initiation message * Section <a href="third-handshake-message">2.3</a> The optional third and subsequent handshake messages * Section <a href="transport-message">2.4</a> Transport message</p>

<h2 id="first-handshake-message">2.1. First handshake message</h2>
<p>In the <strong>First handshake message</strong> client offers server a set of sub-messages, each identified by its own protocol name, ex: <code>Noise_XX_25519_AESGCM_SHA256</code>.</p>
<table style="width:82%;">
<colgroup>
<col width="33%" />
<col width="48%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>packet length (2 bytes)</p></td>
<td><p>number of sub-messages N (1 byte)</p></td>
</tr>
<tr class="even">
<td><p>len (1 byte)</p></td>
<td><p>protocol name</p></td>
</tr>
<tr class="odd">
<td><p>length (2 bytes)</p></td>
<td><p>Sub message body</p></td>
</tr>
<tr class="even">
<td><p>len (1 byte)</p></td>
<td><p>protocol name</p></td>
</tr>
<tr class="odd">
<td><p>length (2 bytes)</p></td>
<td><p>Sub message body</p></td>
</tr>
<tr class="even">
<td><p>....</p></td>
<td></td>
</tr>
<tr class="odd">
<td><p>len (1 byte)</p></td>
<td><p>protocol name</p></td>
</tr>
<tr class="even">
<td><p>length (2 bytes)</p></td>
<td><p>Sub message body</p></td>
</tr>
</tbody>
</table>
<p>Each handshake sub-message contains following fields:</p>
<ul>
<li>1 byte length of the following string, indicating the ciphersuite/protocol used, i.e. message type</li>
<li>String indicating message type</li>
<li>2 bytes big-endian length of following sub-message</li>
<li><strong>Sub message body</strong></li>
</ul>
<table style="width:72%;">
<colgroup>
<col width="23%" />
<col width="48%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>length (1 byte)</p></td>
<td><p>protocol name</p></td>
</tr>
<tr class="even">
<td><p>length (2 bytes)</p></td>
<td><p>Sub message body</p></td>
</tr>
</tbody>
</table>
<h2 id="second-handshake-message">2.2. Second handshake message</h2>
<p>In the <strong>Second handshake message</strong> server responds to client with the following structure:</p>
<ul>
<li>1 byte sub-message index server responds to</li>
<li>Handshake message</li>
</ul>
<h2 id="third-handshake-message">2.3. Third handshake message</h2>
<p>If Noise_XX pattern is used, then there's a need to send the third handshake message from client to server</p>
<h2 id="data-message">2.4. Data message</h2>
<p>After handshake is complete all following packets must be encrypted using those cipherstates.</p>
<h1 id="prologue">3. Prologue</h1>
<p>Noise <a href="#prologue">prologue</a> is calculated as follows:</p>
<ul>
<li>1 byte number of message types (N)</li>
<li>N times:
<ul>
<li>1 byte message type length</li>
<li>Message type (ex. Noise protocol string)</li>
</ul></li>
</ul>
<p>An example of such prologue could be found in Appendix</p>
<h1 id="api">5. API</h1>
<p>We present a set of methods which will help to implement NoiseSocket flow</p>
<ul>
<li><p><strong><code>ReadString(buffer)</code></strong> reads 1 byte <code>len</code> of the following string from <code>buffer</code> and then <code>len</code> bytes string itself. Advances read position to <code>len + 1</code></p></li>
<li><p><strong><code>WriteString(string, buffer)</code></strong> writes 1 byte <code>len</code> of the following string to <code>buffer</code> and then string itself.</p></li>
<li><p><strong><code>ReadData(buffer)</code></strong> reads 2 byte <code>len</code> of the following data from <code>buffer</code> and then <code>len</code> bytes of data. Advances position to <code>len + 2</code></p></li>
<li><p><strong><code>WriteData(data, buffer)</code></strong> writes 2 bytes <code>len</code> of the following data to <code>buffer</code> and then the data itself.</p></li>
<li><p><strong><code>CalculatePrologue(protocols)</code></strong> takes a list of protocol names in the order they will be used in the handshake.</p>
Variables:
<ul>
<li><strong><code>prologue_buffer</code></strong> - a byte buffer to write to</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Writes 1 byte number of protocols <code>N</code> to <code>prologue_buffer</code></li>
<li>Does <code>N</code> times:
<ul>
<li>Takes the next <code>protocol_name</code> from <code>protocols</code></li>
<li>Calls <code>WriteString(protocol_name, prologue_buffer)</code></li>
</ul></li>
</ul>
Returns:
<ul>
<li><code>prologue_buffer</code></li>
</ul></li>
<li><strong><code>ComposeInitiatorHandshakeMessages(s, data, protocols)</code></strong> takes client's static key <code>s</code>, optional payload <code>data</code> and a list of protocols, same that was used for caling <code>CalculatePrologue</code> Variables:
<ul>
<li><strong><code>result_buffer</code></strong> - buffer, containing the resulting byte sequence</li>
<li><strong><code>message_buffer</code></strong> - temporary buffer to hold the result of calling <code>WriteMessage</code> on the current <code>handshake_state</code></li>
<li><strong><code>handshake_states</code></strong> - an array of all instances of <code>HandshakeState</code> objects, created during this method</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Calls <code>CalculatePrologue(protocols)</code> to receive <code>prologue</code></li>
<li>Writes the 1 byte number of protocols <code>N</code> to <code>result_buffer</code></li>
<li>Does <code>N</code> times
<ul>
<li>Takes the next <code>protocol</code> from <code>protocols</code></li>
<li>Calls <code>WriteString(protocol_name, result_buffer)</code></li>
<li>Calls <code>GENERATE_KEYPAIR()</code> to generate new <code>e</code></li>
<li>Initializes new <code>HandshakeState</code> instance with <code>DH functions</code>, <code>Cipher functions</code> and <code>Hash functions</code>, described in <code>protocol</code> and also <code>s</code>, <code>e</code> and <code>prologue</code> to receive <code>handshake_state</code></li>
<li>initializes new <code>message_buffer</code></li>
<li>Calls <code>WriteMessage(data, message_buffer)</code> on <code>handshake_state</code></li>
<li>Calls <code>WriteData(message_buffer, result_buffer)</code></li>
<li>Adds <code>handshake_state</code> to <code>handshake_states</code></li>
</ul></li>
</ul>
Returns:
<ul>
<li><code>result_buffer</code></li>
<li><code>handshake_states</code></li>
</ul></li>
<li><strong><code>ParseFirstMessage(message, s)</code></strong> receives <code>message</code>, created by calling <code>ComposeInitiatorHandshakeMessages</code> and static keypair <code>s</code> Variables:
<ul>
<li><strong><code>protocols</code></strong> - a list of protocol names, parsed from <code>message</code></li>
<li><strong><code>sub_messages</code></strong> - a list of byte sequences in order they were written to <code>message</code> by calling <code>WriteMessage</code></li>
<li><strong><code>handshake_state</code></strong> - a state that was created when server chose one of the incoming messages</li>
<li><strong><code>message_index</code></strong> - an index of the message that server chose</li>
<li><strong><code>payload</code></strong> - an optional payload, provided in the first message</li>
</ul>
Algorithm:
<ul>
<li>Reads 1 byte number of sub-messages <code>N</code></li>
<li>Does <code>N</code> times:
<ul>
<li>Calls <code>ReadString(message)</code> to receive <code>protocol_name</code></li>
<li>Calls <code>ReadData(message)</code> to receive <code>sub_message</code></li>
<li>Appends <code>protocol_name</code> to <code>protocols</code></li>
<li>Appends <code>sub_message</code> to <code>sub_messages</code></li>
</ul></li>
<li>Calls <code>CalculatePrologue(protocols)</code> to receive <code>prologue</code></li>
<li>Chooses a protocol, according to server protocol priority and the corresponding <code>sub_message</code> from <code>sub_messages</code>.</li>
<li>Writes index of the chosen <code>protocol</code> to <code>message_index</code></li>
<li>Calls <code>GENERATE_KEYPAIR()</code> to generate new <code>e</code></li>
<li>Initializes new <code>HandshakeState</code> instance with <code>DH functions</code>, <code>Cipher functions</code> and <code>Hash functions</code>, described in <code>protocol</code> and also <code>s</code>, <code>e</code> and <code>prologue</code> to receive <code>handshake_state</code></li>
<li>Calls <code>ReadMessage(sub_messages)</code> on <code>handshake_state</code> to receive an optional <code>payload</code></li>
</ul>
Returns:
<ul>
<li><code>message_index</code></li>
<li><code>handshake_state</code></li>
<li><code>payload</code></li>
</ul></li>
<li><p><strong><code>ComposeServerResponseMessage(handshake_state, index, data)</code></strong> receives <code>handshake_state</code>, <code>index</code> and optional <code>data</code> to send to client</p>
Variables:
<ul>
<li><strong><code>result_buffer</code></strong> - buffer, containing the resulting byte sequence</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Writes <code>index</code> to <code>result_buffer</code></li>
<li>Calls WriteMessage(result_buffer, data) on handshake_state</li>
</ul>
Returns:
<ul>
<li><code>result_buffer</code></li>
</ul></li>
<li><p><strong><code>SetMaxPacketLen(len)</code></strong> Sets the global valiable <strong><code>max_packet_len</code></strong> to <code>len</code>. <code>len</code> must satisfy the following condition: 127 &lt; <code>len</code> &lt; 65536 . The default value of <strong><code>max_packet_len</code></strong> is 65535</p></li>
<li><p><strong><code>GetMaxPacketLen</code></strong> Returns the number of bytes of the plaintext that can be placed into the current packet</p>
<p>Algorithm:</p>
<ul>
<li>If handshake is not complete return <strong><code>max_packet_len</code></strong></li>
<li>Else return <strong><code>max_packet_len</code></strong> - <strong><code>CIPHER_OVERHEAD</code></strong> . <strong><code>CIPHER_OVERHEAD</code></strong> is the number of bytes added by the chosen symmetric cipher</li>
</ul></li>
<li><p><strong><code>Write(data)</code></strong> writes data to outgoing socket</p>
Variables:
<ul>
<li><strong><code>buffer</code></strong> - temporary buffer</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>While length(data) &gt; 0
<ul>
<li></li>
</ul></li>
</ul>
Returns:
<ul>
<li><code>result_buffer</code></li>
</ul></li>
</ul>
<h1 id="test-vectors">6. Test vectors</h1>
<p>Test vectors consist of one <a href="#first-handshake-message">initial message</a>, <a href="#prologue">prologue</a> and a set of private keys. Two for initiator (static, ephemeral) and two for responder.</p>
<p>Initial message contains 16 sub-messages each correspond to a specific Noise protocol. The order of protocols can be seen in <code>Protocols</code> array.</p>
<p>&quot;Server&quot; chooses which sub-message to answer and this forms a <code>session</code>. Each session contains an array of transport messages which consist of raw wire data (&quot;Packet&quot; field), and payload</p>
<h1 id="ipr">7. IPR</h1>
<p>The NoiseSocket specification (this document) is hereby placed in the public domain.</p>

<h1 id="references" class="unnumbered">8. References</h1>
<div id="refs" class="references">
<div id="ref-Rogaway:2002">
<p>[1] P. Rogaway, “Authenticated-encryption with Associated-data,” in Proceedings of the 9th ACM Conference on Computer and Communications Security, 2002. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" class="uri">http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></p>
</div>
<div id="ref-rfc2104">
<p>[2] H. Krawczyk, M. Bellare, and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication.” Internet Engineering Task Force; RFC 2104 (Informational); IETF, Feb-1997. <a href="http://www.ietf.org/rfc/rfc2104.txt" class="uri">http://www.ietf.org/rfc/rfc2104.txt</a></p>
</div>
<div id="ref-rfc5869">
<p>[3] H. Krawczyk and P. Eronen, “HMAC-based Extract-and-Expand Key Derivation Function (HKDF).” Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt" class="uri">http://www.ietf.org/rfc/rfc5869.txt</a></p>
</div>
</div>
</body>
</html>